:toc: macro

= Описание архитектуры

Условно архитектура программы разделена несколько частей: 

toc::[]

== MeasurementTask

.UML диаграмма группы MeasurementTask
image::UML_Diag_MeasurementTask.jpg[]

Система реального времени в классе MeasurementTask вызывает функцию Execute(), в которой расположен бесконечный цикл и уже в нем вызывается функция Update() интерфейса IUpdater, так как класс Adc наследует класс IUpdater,  вызывается функция класса adc, после "засыпает" на 3 мин и цикл повторяется. 

.measurementTask.h
[source, cpp]
----
#ifndef MEASUREMENTTASK
#define MEASUREMENTTASK

#include "thread.hpp" //For OsWrapper::Thread

class MeasurementTask : public OsWrapper::Thread<128>
{
  public:
    MeasurementTask(IUpdater& adc) : _adc(adc){}
    void Execute() override
    {
      for(;;)
      {
        _adc.Update();
        Sleep(180000ms);
      }
    }
private:
  IUpdater& _adc;  
};

#endif //MEASUREMENTTASK
----

.iUpdater.h
[source, cpp]
----
#ifndef IUPDATER
#define IUPDATER

class IUpdater
{
  public:
    virtual void Update() const = 0;
  
};
#endif
----

== Adc

.UML диаграмма группы Adc
image::UML_Diag_Adc.jpg[]


Класс adc отвечает за настройку АЦП и вызов функций классов для считывания данных с инжекторных каналов. В классе на данный момент реализован считывание 4 инжекторных каналов. 

.adc.h
[source, cpp]
----
#ifndef ADC
#define ADC

#include "iUpdater.h" // for IUpdater
#include "iinjectedchannel.h" // for IInjectedChannel

#include "adc1registers.hpp" // for ADC1
#include "adccommonregisters.hpp" // for ADC

template<auto& ...injectedChannels>
class Adc : public IUpdater
{
public:
  void Update() override
  {
    
    ADC1::CR2::JSWSTART::On::Set(); //Start Conversation
    while(!ADC1::SR::JEOC::ConversionComplete::IsSet())
    {
    }
    

    mInjectedChannels[0]->SetData(ADC1::JDR1::JDATA::Get()); // TODO may go beyond the bounds of the array if you pass a smaller array
    mInjectedChannels[1]->SetData(ADC1::JDR2::JDATA::Get());
    mInjectedChannels[2]->SetData(ADC1::JDR3::JDATA::Get());
    mInjectedChannels[3]->SetData(ADC1::JDR4::JDATA::Get());
  }
private:
    std::array<IInjectedChannel*, sizeof ...(injectedChannels)> mInjectedChannels = {static_cast<IInjectedChannel*> (&injectedChannels)... };
  
};
#endif
----

Функция *_Update_* класса *Adc* который запускает работу АЦП и считывает данные с инжекторных каналов, далее вызывается функция *_SetData_*, интерфейса *IInjectedChannel*, который в свою очередь устанавливает данные в объекте класса *InjectedChannel*, соответствующий определенному инжекторному каналу. Установленные данные необходимо передать в другой класс, за передачу данных отвечает интерфейс *IDataProvider* с функцией *_GetData_*.

.iinjectedchannel.h
[source, cpp]
----
#ifndef IINJECTEDCHANNEL
#define IINJECTEDCHANNEL

class IInjectedChannel
{
  public:
    virtual void SetData(std::uint32_t data) = 0;
};

#endif
----

.idataprovider.h
[source, cpp]
----
#ifndef IDATAPROVIDER
#define IDATAPROVIDER

class IDataProvider
{
  public:
    virtual std::uint32_t GetData() const = 0;
};

#endif
----

Класс InjectedChannel, разбит на заголовочный файл .h и файл исходного кода .cpp.

.injectedchannel.h
[source, cpp]
----
#ifndef INJECTEDCHANNEL
#define INJECTEDCHANNEL

#include <cstdint> // for std::uint32_t
#include "iinjectedchannel.h" // for IInjectedChannel 
#include "idataprovider.h" // for IDataProvider

class InjectedChannel : public IInjectedChannel, IDataProvider
{
  public:
    void SetData(std::uint32_t data) override;
    
    std::uint32_t GetData() const override;
  private:
    std::uint32_t mData;
};

#endif
----

.injectedchannel.cpp
[source, cpp]
----
#include "injectedchannel.h" // for InjectedChannel

void InjectedChannel::SetData(std::uint32_t data)
{
  mData = data;
}

std::uint32_t InjectedChannel::GetData() const
{
  return mData;
}
----

== HeatCalculation

.UML диаграмма группы HeatCalculation
image::UML_Diag_HeatCalculation.jpg[]

== MeasurementTemperatureResistance

.UML диаграмма группы MeasurementTemperatureResistance
image::UML_Diag_MeasurementTemperatureResistance.jpg[]

== WaterConsumption

.UML диаграмма группы Adc
image::UML_Diag_WaterConsumption.jpg[]