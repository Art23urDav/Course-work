:toc: macro

= Описание архитектуры

Условно архитектура программы разделена несколько частей: 

toc::[]

== MeasurementTask

.UML диаграмма группы MeasurementTask
image::UML_Diag_MeasurementTask.jpg[]

Система реального времени в классе MeasurementTask вызывает функцию Execute(), в которой расположен бесконечный цикл и уже в нем вызывается функция Update() интерфейса IUpdater, так как класс Adc наследует класс IUpdater,  вызывается функция класса adc, после "засыпает" на 3 мин и цикл повторяется. 

.measurementTask.h
[source, cpp]
----
#ifndef MEASUREMENTTASK
#define MEASUREMENTTASK

#include "thread.hpp" //For OsWrapper::Thread

class MeasurementTask : public OsWrapper::Thread<128>
{
  public:
    MeasurementTask(IUpdater& adc) : _adc(adc){}
    void Execute() override
    {
      for(;;)
      {
        _adc.Update();
        Sleep(180000ms);
      }
    }
private:
  IUpdater& _adc;  
};

#endif //MEASUREMENTTASK
----

.iUpdater.h
[source, cpp]
----
#ifndef IUPDATER
#define IUPDATER

class IUpdater
{
  public:
    virtual void Update() const = 0;
  
};
#endif
----

== Adc

.UML диаграмма группы Adc
image::UML_Diag_Adc.jpg[]


Класс adc отвечает за настройку АЦП и вызов функций классов для считывания данных с инжекторных каналов. В классе на данный момент реализован считывание 4 инжекторных каналов. 

.adc.h
[source, cpp]
----
#ifndef ADC
#define ADC

#include "iUpdater.h" // for IUpdater
#include "iinjectedchannel.h" // for IInjectedChannel

#include "adc1registers.hpp" // for ADC1
#include "adccommonregisters.hpp" // for ADC

template<auto& ...injectedChannels>
class Adc : public IUpdater
{
public:
  void Update() override
  {
    
    ADC1::CR2::JSWSTART::On::Set(); //Start Conversation
    while(!ADC1::SR::JEOC::ConversionComplete::IsSet())
    {
    }
    

    mInjectedChannels[0]->SetData(ADC1::JDR1::JDATA::Get()); // TODO may go beyond the bounds of the array if you pass a smaller array
    mInjectedChannels[1]->SetData(ADC1::JDR2::JDATA::Get());
    mInjectedChannels[2]->SetData(ADC1::JDR3::JDATA::Get());
    mInjectedChannels[3]->SetData(ADC1::JDR4::JDATA::Get());
  }
private:
    std::array<IInjectedChannel*, sizeof ...(injectedChannels)> mInjectedChannels = {static_cast<IInjectedChannel*> (&injectedChannels)... };
  
};
#endif
----

Функция *_Update_* класса *Adc* который запускает работу АЦП и считывает данные с инжекторных каналов, далее вызывается функция *_SetData_*, интерфейса *IInjectedChannel*, который в свою очередь устанавливает данные в объекте класса *InjectedChannel*, соответствующий определенному инжекторному каналу. Установленные данные необходимо передать в другой класс, за передачу данных отвечает интерфейс *IDataProvider* с функцией *_GetData_*.

.iinjectedchannel.h
[source, cpp]
----
#ifndef IINJECTEDCHANNEL
#define IINJECTEDCHANNEL

class IInjectedChannel
{
  public:
    virtual void SetData(std::uint32_t data) = 0;
};

#endif
----

.idataprovider.h
[source, cpp]
----
#ifndef IDATAPROVIDER
#define IDATAPROVIDER

class IDataProvider
{
  public:
    virtual std::uint32_t GetData() const = 0;
};

#endif
----

Класс *InjectedChannel*, разбит на заголовочный файл .h и файл исходного кода .cpp.

.injectedchannel.h
[source, cpp]
----
#ifndef INJECTEDCHANNEL
#define INJECTEDCHANNEL

#include <cstdint> // for std::uint32_t
#include "iinjectedchannel.h" // for IInjectedChannel 
#include "idataprovider.h" // for IDataProvider

class InjectedChannel : public IInjectedChannel, IDataProvider
{
  public:
    void SetData(std::uint32_t data) override;
    
    std::uint32_t GetData() const override;
  private:
    std::uint32_t mData;
};

#endif
----

.injectedchannel.cpp
[source, cpp]
----
#include "injectedchannel.h" // for InjectedChannel

void InjectedChannel::SetData(std::uint32_t data)
{
  mData = data;
}

std::uint32_t InjectedChannel::GetData() const
{
  return mData;
}
----

Часть кода, отвечающая за объявление объектов класса *InjectedChannel*. 

.main.cpp
[source, cpp]
----

InjectedChannel channelResistanceThermometerDirect;
InjectedChannel channelResistanceThermometerReverse;
InjectedChannel channelPressureMeter1;
InjectedChannel channelPressureMeter2;
Adc<channelResistanceThermometerDirect, channelResistanceThermometerReverse, channelPressureMeter1, channelPressureMeter2> adc1;
MeasurementTask measurementTask(adc1);

----

== MeasurementTemperatureResistance

.UML диаграмма группы MeasurementTemperatureResistance
image::UML_Diag_MeasurementTemperatureResistance.jpg[]

Вначале создадим интерфейс *IInjectedChannelNotifare* для уведомления класса  *ResistanceThermometer* о том что пришли данные. Класс *ResistanceThermometer*, отвечает за преобразования кода с АЦП с инжекторного канала в температуру, полученного из класса *InjectedChannel* с помощью агрегации интерфейса *IDataProvider*.

.iinjectedchannelnotifare.h
[source, cpp]
----
#ifndef IINJECTEDCHANNELNOTIFARE
#define IINJECTEDCHANNELNOTIFARE

class IInjectedChannelNotifare
{
  public:
      virtual void NotifyDataArrived() = 0;
};

#endif
----

Класс *ResistanceThermometer*, разбит на заголовочный файл .h и файл исходного кода .cpp. В функции *_Calculate_* производится преобразования кода с АЦП в температуру. В формуле преобразования угловой коеффициент k и коеффициент смещения b задаются в конструктор при объявлении объекта класса.

.resistancethermometer.h
[source, cpp]
----
#ifndef RESISTANCETHERMOMETER
#define RESISTANCETHERMOMETER

#include <cstdint> // for std::uint32_t
#include <limits> // std::numeric_limits
#include "idataprovider.h" // for IDataProvider and IFloatDataProvider
#include "iinjectedchannelnotifier.h" // for IInjectedChannel 

class ResistanceThermometer : public IInjectedChannelNotifier, public IFloatDataProvider
{
  public:
    ResistanceThermometer(IDataProvider& dataProvider, float gain, float offset) : 
      mDataProvider(dataProvider), 
      mGain(gain),
      mOffset(offset)
    {
    }
    void NotifyDataArrived() override;
    float GetData() const override;
  private:
    float Calculate(std::uint32_t adcCode);
    IDataProvider& mDataProvider;
    float mValue = std::numeric_limits<float>::signaling_NaN();
    float mGain = std::numeric_limits<float>::signaling_NaN();
    float mOffset = std::numeric_limits<float>::signaling_NaN();
    
};

#endif
----

.resistancethermometer.cpp
[source, cpp]
----
#include "resistancethermometer.h" //for ResistanceThermometers
#include <iostream>                   // for std::cout

void ResistanceThermometer::NotifyDataArrived()
{
  mValue = Calculate(mDataProvider.GetData());
  std::cout << mValue << std::endl; // TODO delete 
}

float ResistanceThermometer::Calculate(std::uint32_t adcCode)
{
  mValue = mGain * static_cast<float>(adcCode) + mOffset; 
  return mValue;
}

float ResistanceThermometer::GetData() const
{
  return mValue;
}
----

Изменим injectedchannel.h так чтобы класс мог агрегировать интерфейс *IInjectedChannelNotifare*.


.injectedchannel.h
[source, cpp]
----
#ifndef INJECTEDCHANNEL
#define INJECTEDCHANNEL

#include <cstdint> // for std::uint32_t
#include "iinjectedchannel.h" // for IInjectedChannel 
#include "idataprovider.h" // for IDataProvider
#include "iinjectedchannelnotifare.h" // for IInjectedChannel 

class InjectedChannel : public IInjectedChannel, public IDataProvider
{
  public:
    InjectedChannel(IInjectedChannelNotifare& notifare) : mNotifare(notifare)
    {
    }
    void SetData(std::uint32_t data) override;
    
    std::uint32_t GetData() const override;
  private:
    std::uint32_t mData;
    IInjectedChannelNotifare& mNotifare;
};

#endif
----

Был добавлен интерфейсный класс *IFloatDataProvider* в файле idataprovider.h для передачи данных типа float из класса *ResistanceThermometer*.

.idataprovider.h
[source, cpp]
----
#ifndef IDATAPROVIDER
#define IDATAPROVIDER

class IDataProvider
{
  public:
    virtual std::uint32_t GetData() const = 0;
};

class IFloatDataProvider 
{
  public:
    virtual float GetData() const = 0;
};

#endif
----

Часть кода, отвечающая за объявление объектов классов.

.main.cpp
[source, cpp]
----
extern ResistanceThermometer ResistanceThermometerDirect;
extern ResistanceThermometer ResistanceThermometerReverse;

InjectedChannel channelResistanceThermometerDirect(static_cast<IInjectedChannelNotifier&>(ResistanceThermometerDirect));
InjectedChannel channelResistanceThermometerReverse(static_cast<IInjectedChannelNotifier&>(ResistanceThermometerReverse));

ResistanceThermometer ResistanceThermometerDirect(static_cast<IDataProvider&>(channelResistanceThermometerDirect), 1.0f, 0.0f);
ResistanceThermometer ResistanceThermometerReverse(static_cast<IDataProvider&>(channelResistanceThermometerReverse), 1.0f, 0.0f);

Adc<channelResistanceThermometerDirect, channelResistanceThermometerReverse> adc1;
MeasurementTask measurementTask(adc1);
----

== WaterConsumption

.UML диаграмма группы Adc
image::UML_Diag_WaterConsumption.jpg[]